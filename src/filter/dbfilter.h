/*
 * This file is part of OpenATS COMPASS.
 *
 * COMPASS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * COMPASS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with COMPASS. If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "configurable.h"
#include "appmode.h"
#include "dbfilterwidget.h"

#include "json_fwd.hpp"

#include <string>
#include <vector>

class DBFilterCondition;
class FilterManager;
class Buffer;

namespace dbContent
{
class Variable;
}

class DBFilter : public Configurable
{
  public:
    DBFilter(const std::string& class_id, const std::string& instance_id, Configurable* parent,
             bool is_generic = true);
    virtual ~DBFilter();

    void setActive(bool active);
    bool getActive();

    // returns if the DBContent is filtered by this filter
    virtual bool filters(const std::string& dbcont_name);

    //get if the filter configuration has changed
    bool getChanged();
    //set if the filter configuration has changed
    void setChanged(bool changed);

    bool getVisible();
    void setVisible(bool visible);

    const std::string& getName() const { return name_; }
    void setName(const std::string& name);

    bool isGeneric() { return is_generic_; }

    /// where condition string for a DBContent
    virtual std::string getConditionString(const std::string& dbcontent_name, bool& first);
    bool onlyHasSubFilter() { return conditions_.size() > 0; }

    // resets the filter (sub-filters and conditions) to their inital values.
    virtual void reset();

    virtual void generateSubConfigurable(const std::string& class_id,
                                         const std::string& instance_id);

    std::vector<DBFilterCondition*>& getConditions() { return conditions_; }
    unsigned int getNumConditions() { return conditions_.size(); }
    void deleteCondition(DBFilterCondition* condition);

    DBFilterWidget* widget();

    bool unusable() const { return unusable_; }

    virtual void saveViewPointConditions (nlohmann::json& filters);
    virtual void loadViewPointConditions (const nlohmann::json& filters);

    void updateToAppMode (AppMode app_mode);

    virtual bool activeInLiveMode();
    virtual std::vector<unsigned int> filterBuffer(const std::string& dbcontent_name, std::shared_ptr<Buffer> buffer);

    bool widgetVisible() const;
    void widgetVisible(bool widget_expanded);

protected:
    // FilterManager &filter_manager_;
    std::string name_;

    bool active_ {true}; // active flag, if false no conditions are used

    bool visible_ {true}; // widget expanded flag
    bool unusable_{false};  // if a conditions is unusable
    bool disabled_ {false}; // if disabled due to other reasons (e.g. AppMode)

    bool changed_ {false};

    bool widget_visible_ {true};

    std::vector<DBFilterCondition*> conditions_;

    // widget with configuration elements.
    std::unique_ptr<DBFilterWidget> widget_{nullptr};

    /// Generic flag. Only generic (generated by configuration) can be managed (in the  DBFilterWidget)
    bool is_generic_;

    virtual void checkSubConfigurables();
    virtual DBFilterWidget* createWidget();
};
